*************               Lesson 20: INTRO				                 **************
*************               Lesson 21: Creating the React App		                 **************
-- Inside ReStore folder run npx create-react-app client --template typescript --use-npm
-- ts.config.json file is needed for compiling TS
-- npm start to build and run the client app

*************               Lesson 22: Whats in the template	 	                 **************
-- public/index.html is the entrypoint for the application. Change the title here.
-- cra tooling adds script imports to the file
-- index.tsx calls ReactDOM.render and renders the base App component in react strict mode
-- React has hot reloading
-- Replace everything with a h1 tag and Restore

*************               Lesson 23: React Component basics		                 **************
-- Very basic stuff -- basic styling
-- Vasic array displaying using .map

*************               Lesson 24: useState Hook			                 **************
-- Basic state manipulations 

*************               Lesson 25: useEffect Hook			                 **************
*************               Lesson 26: API CORS Configurations			                 **************
-- Go to Startup class. Goal is to send back a header with CORS information
-- Service registering
            services.AddCors();

-- Middleware registering
            app.UseCors(opt => {
                opt.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:3000");
            });


*************               Lesson 27: TS vs JS in React			                 **************
-- TS is a superset of JS, hence all normal JS code can run perfectly fine in TS
-- Syntax errors like just naming a property of an object incorrectly gets caught by TS,
    while this shows as a runtime error in JS
    TS shows an error both on the IDE and in the browser. In JS things can fail silently.
    TS can infer from our code what types are being used i.e. the shape of objects.
    Sometimes type safety is not worth the advantage
    It is worth it for Products, as this is a fundemantal entity in our API

*************               Lesson 28: Adding a TS interface for the products          **************
-- This can allow TS to be aware of the shape of our product object
-- This is needed because we will not be setting any default data for TS to infer
-- Inside our source folder create a product.ts file
-- We can use a json to ts converter to get a shape to avoid any typos
-- We can specify a type for useState by passing in an interface or builtin type inside angle brackets
-- The square brackets there indicate that it is an array of that type
useState<Product[]>([]);
-- We do however get an error relating to the add product function since our adding object does not
    match the shape that typescript is expecting.
-- We can mark a property as optional via a ? next to its name in the interface file