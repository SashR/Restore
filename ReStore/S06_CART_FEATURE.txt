*************               Lesson 61: Introduction                **************
-- We will be working on both API and Client
-- We will look at storage of the basket (client vs db)
-- Relationships in EF 
-- Shaping data being returned from the API (SELECT statement)
-- Applying React context
-- App Initialization

-- Local storage on browser is not a great option as the server is completely unaware, hence preventing
    many analytics opportunities.
-- Cookies are also an option, they are also persistent on the client, but they get sent as part of every
    request.
-- Final option is storing in the database, but here we need to update both client and server
-- We will not be tracking the individual basket changes

-- Relationships: Each (One) Basket can have (Many) Items; Each Item is a Product (One to One)
-- React Context allows avoiding extreme prop drilling. providing data easily across the depth of a tree.
-- Allows for centralizing some of our state


*************               Lesson 62: Creating the basket entity                **************
-- We are choosing the Database option. Hence we need some tables, and APIs to interact with it.
-- Create new C# class for entity under entities
-- Add properties and helper methods (Add/remove sub entities)
-- Register entity in StoreContext.cs class



*************               Lesson 63: EF Relationships                **************
-- We did not add a seperated DBSet for Basket Items, because we will never query them directly,
    only via their relationship with the Basket.
-- We need to create our migration, stop the API SERVER and execute the following command:
dotnet ef migrations add BasketEntityAdded
-- We can now find new files in our Migrations folder. We can change table names via data annotations later.
-- The migration generated might not match what we want
-- Check the ondelete behavior of the foreign contraints; Cascade or Restrict
-- Restrict will cause child entities to persist even if the parent is deleted.
-- This is not good for relationships where one entity is entirely dependent on the other existing.
-- Some fields may be nullable when they shouldn't be.
-- We should run the below command to remove this shit migration:
dotnet ef migrations remove 

-- Checkup fully defined relationships in the MS docs.
public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    public List<Post> Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }             // ********
    public Blog Blog { get; set; }
}
-- The child needs a fully definition i.e. identify foreign key in Parent table
// Fully definitions
public int BasketId {get; set;}
public Basket Basket {get; set; }
-- We can then use data annotations to rename the table
[Table("BasketItems")]
-- We can run our migrations command again, check the migration to make sure all is well
-- We can now restart our server to apply the migration

*************               Lesson 6                **************
*************               Lesson 6                **************
*************               Lesson 6                **************
*************               Lesson 6                **************
*************               Lesson 6                **************
*************               Lesson 6                **************
*************               Lesson 6                **************