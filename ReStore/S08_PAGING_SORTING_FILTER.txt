*************               Lesson 103: Adding sorting to the API                **************
        public async Task<ActionResult<List<Product>>> GetProducts(string orderBy)
        {
            var query = _context.Products.AsQueryable();  // Fetches products and allows it to be queried (filtered, etc)

            query = orderBy switch
            {
                "price"     => query.OrderBy(p => p.Price),
                "priceDesc" => query.OrderByDescending(p => p.Price),
                _           => query.OrderBy(p => p.Name)
            };

            return await query.ToListAsync(); // Executes built up query against DB and returns result
        }
--> The code will get messy fast with all of the queries.
--> Alternative is Repository Pattern, which move DB logic from controllers into a central place. Not covered in course
--> The DBContext class is a combination of the unit of work and the repository pattern.
--> We will use extension methods, and move queries to that

--> Create folder api\Extensions
--> Create filter ProductExtensions.cs, all extensions to the Products class held here.
--> The idea of Extension methods is to essentially extend the functionality of built in classes, in this case it is the IQyueryable class

    public static class ProductExtensions // We do not want to create a new instance whenever we want to use a method here
    {
        // All methods will be static
        public static IQueryable<Product> Sort(this IQueryable<Product> query, string orderBy)
        {
            if(string.IsNullOrWhiteSpace(orderBy)) return query.OrderBy(p => p.Name);

            query = orderBy switch
            {
                "price"     => query.OrderBy(p => p.Price),
                "priceDesc" => query.OrderByDescending(p => p.Price),
                _           => query.OrderBy(p => p.Name)
            };

            return query;
        }
    }
--> Query code goes inside extension
        public async Task<ActionResult<List<Product>>> GetProducts(string orderBy)
        {
            var query = _context.Products
                .Sort(orderBy)
                .AsQueryable();  // Fetches products and allows it to be queried (filtered, etc)

            return await query.ToListAsync(); // Executes built up query against DB and returns result
        }

Changes made to S07, this file, ProductsController, Extensions\ProductExtensions.cs

*************               Lesson 104: Adding search functionality to the API                **************
-- Attempted
        public static IQueryable<Product> Search(this IQueryable<Product> query, string searchString)
        {
            if(string.IsNullOrWhiteSpace(searchString)) return query;
            return query.Where(p => p.Name.Contains(searchString));
        }

Changes made to this file, ProductsController.cs, ProductExtensions.cs

--> Almost correct. Check needs to be normalized
        public static IQueryable<Product> Search(this IQueryable<Product> query, string searchString)
        {
            if(string.IsNullOrWhiteSpace(searchString)) return query;
            return query.Where(p => p.Name.ToLower().Contains(searchString.Trim().ToLower()));
        }
Changes made to this file, ProductExtensions



*************               Lesson 105: Adding filters to the API                **************
--> Attempted
        public static IQueryable<Product> Filter(this IQueryable<Product> query, string field, string value)
        {
            if(string.IsNullOrWhiteSpace(field) || string.IsNullOrWhiteSpace(value)) return query;  // return if either field is empty
            if(field == "type") return query.Where(p => p.Type == value);   // filter by type
            else if (field == "brand") return query.Where(p => p.Brand == value);   // filter by brand
            else return query;  // return without filtering
        }
--> Only capable of adding a single filter

Changes made to this file; ProductExtensions; ProductsController

--> More capable solution below
        public static IQueryable<Product> Filter(this IQueryable<Product> query, string brands, string types)
        {
            // temp variables creation
            var brandList = new List<string>();
            var typeList = new List<string>();

            // Populating Lists
            if(!string.IsNullOrEmpty(brands)) brandList.AddRange(brands.ToLower().Split(",").ToList());
            if(!string.IsNullOrEmpty(types)) typeList.AddRange(types.ToLower().Split(",").ToList());

            // Filtering based on lists
            query = brandList.Count == 0    ? query : query.Where(p => brandList.Contains(p.Brand.ToLower()));
            query = typeList.Count == 0     ? query : query.Where(p => typeList.Contains(p.Type.ToLower()));

            return query;
        }
--> Allows for filtering by both types and brands, and multiple of them

Changes made to this file; ProductExtensions; ProductsController


*************               Lesson 106: Adding a Pagination helper function                **************
--> If we have a massive amount of data, it is not sensible to return all of that data (1 mil products), when the user
    can't see them all, and likely won't want to.
--> To solve this we use pagination to chunk the data we send to the client

--> PaginationParams needs properties for the page number, items size and items max size
--> A rule of thumb for parameters, its better to move them if they are more than 3
--> Hence ProductParams class

--> We will have a MetaData class to hold pagination and params details

Changes made to this file, RequestHelpers\PaginationParams.cs; RequestHelpers\ProductParams.cs; RequestHelpers.MetaData.cs




*************               Lesson 107: Creating a class that extends our List into a PagedList                **************
--> Combine MetaData (pagination info) to List
--> Created class for PagedList, combines metadata, provides a function for generating paged list i.e.
    taking pagination properties and slicing the entire list to generate the specified amount of items
--> See code for details

Changes made to this file; RequestHelpers\PagedList.cs; ProductsController.cs

*************               Lesson 10:                **************
*************               Lesson 10:                **************